package main

import (
	"bytes"
	"fmt"
	"io"
	"io/ioutil"
	"math"
	"net"
	"net/http"
	"time"

	"github.com/brutella/hc/hap"
	"howett.net/plist"
)

type ServerInfo struct {
	ACL            int64  `plist:"acl"`
	DeviceID       string `plist:"deviceid"`
	Features       int64  `plist:"features"`
	MacAddress     string `plist:"macAddress"`
	Model          string `plist:"model"`
	OSBuildVersion string `plist:"osBuildVersion"`
	Protovers      string `plist:"protovers"`
	Srcvers        string `plist:"srcvers"`
}

type PairSetupPin1Response struct {
	Pk   []byte
	Salt []byte
}

func getXML(url string) ([]byte, error) {
	resp, err := http.Get(url)
	if err != nil {
		return nil, fmt.Errorf("Error making GET request: %v", err)
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("Error reading response body: %v", err)
	}
	return body, nil
}

func getServerInfo(ip net.IP, port int) ServerInfo {
	url := fmt.Sprintf("http://%v:%d/server-info", ip, port)
	res, err := getXML(url)
	if err != nil {
		fmt.Printf("Error getting XML: %v", err)
		panic(err)
	}
	var serverInfo ServerInfo
	var returnVal ServerInfo
	format, err := plist.Unmarshal(res, &serverInfo)
	if err != nil {
		panic(err)
	}
	if format == 1 {
		returnVal = serverInfo
	} else {
		fmt.Println("plist unmashal was unsuccessful")
	}
	return returnVal
}

func checkForFeatures(ip net.IP, port int) bool {
	serverInfo := getServerInfo(ip, port)
	features := serverInfo.Features
	featuresToCheck := []int64{int64(math.Pow(2, 0)), int64(math.Pow(2, 7)), int64(math.Pow(2, 9))}
	result := true
	for _, bitmask := range featuresToCheck {
		if features&bitmask != bitmask {
			result = false
			break
		}
	}
	return result
}

func connect(addr string) (net.Conn, error) {
	timeout := (time.Duration).Milliseconds(5000)
	socket, err := net.DialTimeout("tcp", addr, time.Duration(timeout))
	if err != nil {
		return nil, err
	}
	return socket, nil
}

func doPairSetupPin1(socket net.Conn) (*PairSetupPin1Response, error) {
	pairSetupPinRequestData, err := CreatePList(map[string]string{
		"method": "pin",
		"user":   "AirPlay",
	})
	if err != nil {
		return nil, err
	}
	pairSetupPin1ResponseBytes, err := PostData(socket, "/pair-setup-pin", "application/x-apple-binary-plist", pairSetupPinRequestData)
	if err != nil {
		return nil, err
	}
	pairSetupPin1Response, err := Parse(pairSetupPin1ResponseBytes)
	if err != nil {
		return nil, err
	}
	if _, okPk := pairSetupPin1Response["pk"]; okPk {
		if _, okSalt := pairSetupPin1Response["salt"]; okSalt {
			pkBytes := pairSetupPin1Response["pk"].([]byte)
			saltBytes := pairSetupPin1Response["salt"].([]byte)
			return &PairSetupPin1Response{Pk: pkBytes, Salt: saltBytes}, nil
		}
	}
	return nil, fmt.Errorf("missing 'pk' and/or 'salt' keys in response")
}

func CreatePList(data map[string]string) ([]byte, error) {
	var b bytes.Buffer
	enc := plist.NewEncoder(&b)
	err := enc.Encode(data)
	if err != nil {
		return nil, err
	}
	return b.Bytes(), nil
}

func PostData(socket net.Conn, path, contentType string, data []byte) ([]byte, error) {
	req, err := http.NewRequest("POST", path, bytes.NewReader(data))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", contentType)

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("unexpected HTTP status code: %d", resp.StatusCode)
	}

	responseData, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	return responseData, nil
}

func Parse(data []byte) (map[string]interface{}, error) {
	var plistData map[string]interface{}
	_, err := plist.Unmarshal(data, &plistData)
	if err != nil {
		return nil, err
	}
	return plistData, nil
}

func pairPinStart(b io.Reader) (io.Reader, error) {
	return sendTLV8(b, "pair-pin-start")
}

func pairSetupPin(b io.Reader) (io.Reader, error) {
	return sendTLV8(b, "pair-setup-pin")
}

func sendTLV8(b io.Reader, endpoint string) (io.Reader, error) {
	url := fmt.Sprintf("http://192.168.1.55:7000/%s", endpoint)
	resp, err := http.Post(url, hap.HTTPContentTypePairingTLV8, b)
	fmt.Print(resp.Body, resp.Header)
	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("Invalid status code %v", resp.StatusCode)
	}
	return resp.Body, err
}

func main() {
	ip := net.ParseIP("192.168.1.35")
	serv := getServerInfo(ip, 7000)
	fmt.Println(serv)
	checkForFeatures(ip, 7000)
}
